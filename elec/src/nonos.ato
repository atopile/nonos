#pragma experiment("BRIDGE_CONNECT")

import ElectricPower
import ElectricLogic
import I2S
import UART
import I2C
import USB2_0

from "atopile/st-stusb4500/st-stusb4500.ato" import STUSB4500
from "atopile/rpi-cm5/cm5.ato" import CM5
from "atopile/ti-tps54560x/ti-tps54560x.ato" import TPS54560x
from "atopile/saleae-header/saleae-header.ato" import SaleaeHeader
from "atopile/ti-tas5825mrhbr/ti_tas5825mrhbr.ato" import Texas_Instruments_TAS5825MRHBR_driver
from "atopile/adi-adau145x/adau145x.ato" import Analog_Devices_ADAU145x_driver
from "atopile/ti-tlv75901/ti-tlv75901.ato" import TLV75901_driver

from "parts/JST_Sales_America_B02B_XASK_1_A_LF__SN/JST_Sales_America_B02B_XASK_1_A_LF__SN.ato" import JST_Sales_America_B02B_XASK_1_A_LF__SN_package
from "parts/TE_Connectivity_1_2328702_0/TE_Connectivity_1_2328702_0.ato" import TE_Connectivity_1_2328702_0_package
from "parts/HCTL_HC_TYPE_C_24P_VS9_3_5A_F1_1_04/HCTL_HC_TYPE_C_24P_Driver.ato" import HCTL_HC_TYPE_C_24P_VS9_3_5A_F1_1_04_driver


module NONOS:
    """
    An opensource sonos era 100 clone
    """

    # Components
    cm5 = new CM5
    regulator_5v = new TPS54560x
    regulator_3v3 = new TLV75901_driver
    amplifier = new Texas_Instruments_TAS5825MRHBR_driver
    pd_controller = new STUSB4500
    usb_connector = new HCTL_HC_TYPE_C_24P_VS9_3_5A_F1_1_04_driver
    dsp = new Analog_Devices_ADAU145x_driver

    # Connectors
    board_to_board_connector = new TE_Connectivity_1_2328702_0_package
    full_range_speaker_connector = new JST_Sales_America_B02B_XASK_1_A_LF__SN_package
    tweeter_speaker_connector = new JST_Sales_America_B02B_XASK_1_A_LF__SN_package
    debug_headers = new SaleaeHeader[3]

    # Power rails
    power_20v = new ElectricPower
    power_5v = new ElectricPower
    power_3v3 = new ElectricPower

    # Specify voltages on power rails
    power_5v.voltage = 5V +/- 5%
    power_3v3.voltage = 3.3V +/- 5%

    # addressing
    pd_controller.i2c.address = 0x28 # Why is this here? Should be in package

    # substitute default pd_controller.usb_connector
    pd_controller.usb_connector.exclude_from_bom = True
    usb_connector.power_vbus ~ pd_controller.pd_controller.power_vbus
    usb_connector.cc[0] ~ pd_controller.pd_controller.cc1
    usb_connector.cc[1] ~ pd_controller.pd_controller.cc2
    usb_connector.usb2 ~ pd_controller.usb2
    pd_controller.i2c ~ cm5.i2cs[0]

    # TOOD: make this work instead
    # pd_controller.usb_connector -> HCTL_HC_TYPE_C_24P_VS9_3_5A_F1_1_04

    # Power supply connections
    pd_controller.power_out ~ power_20v
    power_20v ~> regulator_5v ~> power_5v
    power_5v ~> regulator_3v3 ~> power_3v3

    # Power for devices
    power_5v ~ cm5.power_5v
    power_3v3 ~ dsp.power
    power_3v3 ~ pd_controller.power_mcu
    power_20v ~ amplifier.power_pvdd
    power_3v3 ~ amplifier.power_dvdd

    # amplifier
    cm5.i2cs[0] ~ amplifier.i2c
    cm5.cm5.gpio[3] ~ amplifier.mute
    cm5.cm5.gpio[4] ~ amplifier.warn
    cm5.cm5.gpio[5] ~ amplifier.fault
    cm5.cm5.gpio[6] ~ amplifier.pdn

    # speaker outputs
    amplifier.output_a.p.line ~ full_range_speaker_connector.1
    amplifier.output_a.n.line ~ full_range_speaker_connector.2
    amplifier.output_b.p.line ~ tweeter_speaker_connector.2
    amplifier.output_b.n.line ~ tweeter_speaker_connector.1

    # Hat Connector - Inverted pinout (relative to hat)
    board_to_board_connector.10 ~ cm5.i2cs[1].sda.line
    board_to_board_connector.9 ~ cm5.i2cs[1].scl.line
    board_to_board_connector.8 ~ power_5v.vcc
    board_to_board_connector.7 ~ power_5v.gnd
    board_to_board_connector.6 ~ power_3v3.vcc
    board_to_board_connector.5 ~ power_3v3.gnd
    board_to_board_connector.4 ~ cm5.cm5.gpio[16].line # nfc.reset.line
    board_to_board_connector.3 ~ cm5.cm5.gpio[17].line # nfc.interrupt.line
    board_to_board_connector.2 ~ cm5.cm5.gpio[22].line # touch.interrupt.line
    board_to_board_connector.1 ~ cm5.cm5.gpio[23].line # led_data.line

    # dsp
    dsp.reset_disable ~ cm5.cm5.gpio[20]  # TODO: which pin?
    dsp.model.i2c ~ cm5.i2cs[0]

    # workaround for incorrect .required in dsp package
    _pll_mclk = new ElectricLogic
    dsp.pll_mclk ~ _pll_mclk

    # TODO: review
    # TODO: cm5 I2S interface
    cm5_i2s = new I2S
    cm5_i2s.sck ~ cm5.cm5.gpio[18]
    cm5_i2s.ws ~ cm5.cm5.gpio[19]
    cm5_i2s.sd ~ cm5.cm5.gpio[21]
    cm5_i2s ~ dsp.model.i2s_ins[0]
    dsp.model.i2s_outs[0] ~ amplifier.i2s

    # debug headers
    debug_uart = new UART
    # cm5.uart0 ~ debug_uart
    cm5.uart0.base_uart.tx ~ debug_headers[0].ch0
    cm5.uart0.base_uart.rx ~ debug_headers[0].ch1
    power_3v3.lv ~ debug_headers[0].gnd

    debug_i2c = new I2C
    cm5.i2cs[0] ~ debug_i2c
    cm5.i2cs[0].scl ~ debug_headers[1].ch0
    cm5.i2cs[0].sda ~ debug_headers[1].ch1
    power_3v3.lv ~ debug_headers[1].gnd

    debug_i2s = new I2S
    cm5_i2s ~ debug_i2s
    debug_i2s.sck ~ debug_headers[2].ch0
    debug_i2s.ws ~ debug_headers[2].ch1
    power_5v.hv ~ debug_headers[2].ch3.line
    power_3v3.lv ~ debug_headers[2].gnd

    # Name ethernet diff pairs
    cm5.cm5.ethernet.pairs[0].n.line.override_net_name = "eth0_N"
    cm5.cm5.ethernet.pairs[0].p.line.override_net_name = "eth0_P"
    cm5.cm5.ethernet.pairs[1].n.line.override_net_name = "eth1_N"
    cm5.cm5.ethernet.pairs[1].p.line.override_net_name = "eth1_P"
    cm5.cm5.ethernet.pairs[2].p.line.override_net_name = "eth2_P"
    cm5.cm5.ethernet.pairs[2].n.line.override_net_name = "eth2_N"
    cm5.cm5.ethernet.pairs[3].p.line.override_net_name = "eth3_P"
    cm5.cm5.ethernet.pairs[3].n.line.override_net_name = "eth3_N"