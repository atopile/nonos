import ElectricPower
import I2S

from "atopile/st-stusb4500/st-stusb4500.ato" import STUSB4500
from "atopile/rpi-cm5/cm5.ato" import CM5
from "atopile/ti-tps54560x/ti-tps54560x.ato" import TPS54560x
from "atopile/saleae-header/saleae-header.ato" import SaleaeHeader
from "atopile/ti-tas5825mrhbr/ti_tas5825mrhbr.ato" import Texas_Instruments_TAS5825MRHBR_driver

# from "components/hctl_hc_type_c24p_vs935a_f1104.py" import HCTL_HC_TYPE_C_24P_VS9_3_5A_F1_1_04
# from "hat_board/TE_Connectivity_1_2328702_0.py" import BoardToBoardConnectorInverted
# from "components/js_tsales_america_b02b_xa_sk1al_fsn.py" import JST_Sales_America_B02B_XASK_1_ALFSN

module NONOS:
    cm5 = new CM5
    regulator_5v = new TPS54560x
    amplifier = new Texas_Instruments_TAS5825MRHBR_driver
    # pd_controller_top = new STUSB4500
    # usb_connector = new HCTL_HC_TYPE_C_24P_VS9_3_5A_F1_1_04

    # board_to_board_connector = new BoardToBoardConnectorInverted
    # full_range_speaker_connector = new JST_Sales_America_B02B_XASK_1_ALFSN
    # tweeter_speaker_connector = new JST_Sales_America_B02B_XASK_1_ALFSN

    power_20v = new ElectricPower
    power_5v = new ElectricPower
    power_3v3 = new ElectricPower

    debug_headers = new SaleaeHeader[3]

    # addressing
    # pd_controller_top.i2c.address = 0x28

    # substitute default pd_controller.usb_connector
    # pd_controller_top.usb_connector.exclude_from_bom = True
    # usb_connector.power_vbus ~ pd_controller.pd_controller.power_vbus
    # usb_connector.cc[0] ~ pd_controller.pd_controller.cc1.line
    # usb_connector.cc[1] ~ pd_controller.pd_controller.cc2.line
    # usb_connector.usb2 ~ pd_controller.usb2
    # pd_controller_top.i2c ~ cm5.i2cs[0]

    # TOOD: make this work instead
    # pd_controller.usb_connector -> HCTL_HC_TYPE_C_24P_VS9_3_5A_F1_1_04

    # power
    # pd_controller_top.power_out ~ power_20v
    regulator_5v.power_in ~ power_20v
    regulator_5v.power_out ~ power_5v
    power_5v ~ cm5.power_5v
    # power_3v3 ~ pd_controller_top.power_mcu
    cm5.power_3v3 ~ power_3v3  # onboard regulator can provide 3v3

    # amplifier
    amplifier.power_pvdd ~ power_20v
    amplifier.power_dvdd ~ power_3v3
    cm5.i2cs[0] ~ amplifier.i2c
    cm5.cm5.gpio[3] ~ amplifier.mute
    cm5.cm5.gpio[4] ~ amplifier.warn
    cm5.cm5.gpio[5] ~ amplifier.fault
    cm5.cm5.gpio[6] ~ amplifier.pdn

    # TODO: review
    # TODO: cm5 I2S interface
    cm5_i2s = new I2S
    cm5_i2s.sck ~ cm5.cm5.gpio[18]
    cm5_i2s.ws ~ cm5.cm5.gpio[19]
    cm5_i2s.sd ~ cm5.cm5.gpio[21]
    cm5_i2s ~ amplifier.i2s



    # # infix operators with list literals don't work super nicely
    # [amplifier.output_a.p.signal, amplifier.output_a.n.signal] ~ [full_range_speaker_connector.unnamed[0], full_range_speaker_connector.unnamed[1]]
    # [amplifier.output_b.p.signal, amplifier.output_b.n.signal] ~ [tweeter_speaker_connector.unnamed[0], tweeter_speaker_connector.unnamed[1]]

    # # hat board
    # board_to_board_connector.i2c ~ cm5.i2c
    # board_to_board_connector.power_3v3 ~ power_3v3
    # board_to_board_connector.power_5v ~ power_5v

    # # address selectors? e.g. with list of attrs
    # cm5.gpio[4:8] ~ board_to_board_connector.[hat_reset, hat_nfc_irq, hat_touch_irq, hat_led_data]

    # # debug headers
    # [cm5.uart_tx, cm5.uart_rx] ~ debug_headers[0].pins[0, 1]
    # [cm5.i2c.scl, cm5.i2c.sda] ~ debug_headers[0].pins[2, 3]
    # [cm5.i2s.sck, cm5.i2s.ws, cm5.i2s.sd] ~ debug_headers[1].pins[0, 1, 2]
    # power_5v.hv ~ debug_headers[1].pins[3].signal
